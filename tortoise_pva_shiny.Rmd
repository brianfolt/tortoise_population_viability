---
output: html_document
runtime: shiny
---

<link rel="stylesheet" href="styles.css" type="text/css">

<style type="text/css">
body{ /* Normal  */ font-size: 16px; font-family: Arial; color:black}
td {  /* Table  */ font-size: 8px;}
h1.title {font-size: 38px; color: DarkRed;}
h1 { /* Header 1 */ font-size: 28px; color: Black;}
h2 { /* Header 2 */ font-size: 22px; color: Black;}
h3 { /* Header 3 */ font-size: 18px; color: Black;}
code.r{ /* Code block */ font-size: 12px;}
pre { /* Code block - determines code spacing between lines */ font-size: 14px;}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Gopher tortoise (*Gopherus polyphemus*) populations experience varying demographic conditions across the species' range in the southeastern United States. I built a flexible tool to allow users to simulate tortoise population growth and population demographic conditions under varying conditions of individual growth rates, survival, and reproduction.

## Inputs and Outputs

Specify population vital rates in the left panel (age of maturity, survival, fecundity), and simulation features. Then click the 'Run simulations' button to estimate demographic parameters and project the population into the future.

```{r pva, echo=FALSE}

library(popbio)

shinyApp(
  
  fluidPage(
    #titlePanel("Demographic rates"),
    sidebarLayout(
      sidebarPanel(
        h4(p(strong("Demographic Rates"))),
        numericInput("ma", "Age of maturity:", 18, min = 5, max = 30),
        numericInput("pf", "Probability that a female lays eggs:", 0.97, 0, 1, step=0.01),
        numericInput("f", "Clutch size:", 6, 0, 25, step=1),
        numericInput("ns", "Probability of nest survival:", 0.35, 0, 1, step=0.01),
        numericInput("pv", "Probability of egg viability:", 0.35, 0, 1, step=0.01),
        numericInput("pf", "Probability of female:", 0.35, 0, 1, step=0.01),
        numericInput("s_h", "Probability of hatchling survival:", 0.13, 0, 1, step=0.01),
        numericInput("s_j", "Probability of juvenile survival:", 0.75, 0, 1, step=0.01),
        numericInput("s_f", "Probability of hatchling survival:", 0.86, 0, 1, step=0.01),
        numericInput("n", "Initial population size:", 50, 0, 10000, step=1),
        br(),
        h4(p(strong("Simulation Inputs"))),
        numericInput("nyears", "Projection interval (years)", 50, 1, 100),
        numericInput("nreps", "Number of simulation replicates", 10, 5, 50),
        br(),
        actionButton("run", "Perform simulation",
                     class = "btn-success",
                     style="color: #fff; background-color: #337ab7; border-color: #2e6da4")
        ),

      mainPanel(
        plotOutput("plot")
      )
    )
  ),
  
  server <- function(input, output, session) {
    
      datAdv <- eventReactive(input$run, {
        
        # # Use 'req()' to require certain inputs to perform simulations
        # req(input$ma, input$pf, input$f, input$ns, input$pv, input$pf,
        #     input$s_h, input$s_j, input$s_f,
        #     # Simulation inputs
        #     input$nyears, input$nreps)
        
        withProgress(message = "Simulating population growth", {
      
        ### 1) Specify User Inputs 
        
        # Population parameters
        ma <- input$ma
        pf <- input$pf
        f <- input$f
        ns <- input$ns
        pv <- input$pv
        pf <- input$pf
        s_h <- input$s_h
        s_j <- input$s_j
        s_f <- input$s_f
        
        # Specify productivity of juvenile and adult females
        demog_sched[ma, "mx"] <- bp * f * s_n * ve * pf *s_h
  
        # Specify juvenile and adult survival rates
        demog_sched[1:(ma-1), "sx"] <- s_j
        demog_sched[ma, "sx"] <- s_a
        
        # Construct a Leslie matrix from this demography schedule
        A <- make_Leslie_matrix(demog_sched)
        
        ## Demographic features
        
        # Calculate the asymptotic growth rate of the population governed by this 
        #   demography schedule:
        lam <- mpmtools::lambda1(A)
        ssd <- popbio::stable.stage(A) # Stable stage (age) distribution
        generation.time <- popbio::generation.time(A) # Generation time
        rv <- reproductive.value(A)  # Reproductive value
        elas <- elasticity(A) # Elasticity values
        elas.values <- c(diag(elas[-1,]), elas[ma-1,ma-1], elas[1,ma-1])
        
        
        ### Project and track population structure
        
        # Starting population size
        n <- input$n
        
        # Simulation parameters
        nyears <- input$nyears
        nreps <- input$nreps
        
        nstages <- dim(A)[1]
        
        # Matrices to save population size and structure
        N_tot <- matrix(0, nyears, nreps)
        N_stages <- array(0, c(nyears, nreps, nstages))
        # array to save population structure across years, reps, and ages
        
        ## Initial population size and structure
        # What is the stable-stage distribution (SSD) of the matrix
        ssd <- stable.stage(A)
        
        # How many individuals in the population?
        n <- 50
        
        # Spread individuals across the SSD
        n_ssd <- ssd * n
        
        # Use poisson draws to randomly populate numbers per stage for each simulation
        #   replicate
        n_i <- matrix(NA, nreps, dim(A)[1])
        for (i in 1:nreps){
          n_i[i,]  <- rpois(length(n_ssd), n_ssd)
        }
        # rowSums(n_i) # usually between 40-60 females to start
        
        ## Partition matrix for simulation
        x <- splitA(A)
        x_T <- x$T
        x_F <- x$F
        
        ## Run the simulation!
        for (j in 1:nreps){ # for each replicate
          n_i_j <- n_i[j,] # specify initial population size, randomly drawn above
          for (i in 1:nyears){ # for each year
            # If it's the first year, specify n_i_j; else,
            #   specify N_stage from previous year
            if(i == 1){
              n_sim <- n_i_j
            } else {
                n_sim <- N_stages[i-1,j,]
                }
            N_stages[i,j,] <- multiresultm(n_sim, x_T, x_F) # project pop
            N_tot[i,j] <- sum(N_stages[i,j,]) # save N
          } #year
        } #rep
        
        print("Hello World")
      
    }) # end-withProgress
  }) # end-dat
      
  # ## Create an output object where we will save all the graphs and tables 
  # ##  from the Basic Tool
  # graphs <- reactiveValues(g1=NULL)
  # 
  # ## Summary graph 1 - abundance ------------
  # output$n <- renderPlot({
  #   
  #   # Create and store the graph in graphsBasic object
  #   graphs$n <- matplot(N_tot, type = 'l', log= "y",
  #       xlab = 'Time (years)', ylab = 'Total population')
  #   
  #   # Print the graph
  #   graphs$n
  #   
  # })

    output$plot <- renderPlot({
      matplot(N_tot, type = 'l', log="y",
        xlab = 'Time (years)', ylab = 'Total population')
    }, res = 96)
    
  },

  options = list(height = 1200)  
)

```




It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r tabsets, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package = "shiny"),
  options = list(
    width = "100%", height = 550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.

